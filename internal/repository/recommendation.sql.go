// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recommendation.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getTracksToRevisit = `-- name: GetTracksToRevisit :many
WITH past_stats AS (
    SELECT 
        track_id,
        COUNT(*) AS past_listen_count,
        MAX(listened_at) AS last_listened_at
    FROM listens l
    WHERE l.listened_at BETWEEN $1 AND $2
    GROUP BY track_id
    HAVING COUNT(*) >= 5
),
recent_listens AS (
    SELECT DISTINCT track_id
    FROM listens
    WHERE listened_at > $2
)
SELECT 
    t.id AS track_id,
    t.title,
    t.release_id,
    r.image AS release_image,
    get_artists_for_track(t.id) AS artists,
    p.past_listen_count,
    p.last_listened_at
FROM past_stats p
JOIN tracks_with_title t ON p.track_id = t.id
JOIN releases r ON t.release_id = r.id
LEFT JOIN recent_listens recent ON p.track_id = recent.track_id
WHERE recent.track_id IS NULL
ORDER BY p.past_listen_count DESC
LIMIT $3
`

type GetTracksToRevisitParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	Limit        int32
}

type GetTracksToRevisitRow struct {
	TrackID         int32
	Title           string
	ReleaseID       int32
	ReleaseImage    *uuid.UUID
	Artists         []byte
	PastListenCount int64
	LastListenedAt  interface{}
}

func (q *Queries) GetTracksToRevisit(ctx context.Context, arg GetTracksToRevisitParams) ([]GetTracksToRevisitRow, error) {
	rows, err := q.db.Query(ctx, getTracksToRevisit, arg.ListenedAt, arg.ListenedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksToRevisitRow
	for rows.Next() {
		var i GetTracksToRevisitRow
		if err := rows.Scan(
			&i.TrackID,
			&i.Title,
			&i.ReleaseID,
			&i.ReleaseImage,
			&i.Artists,
			&i.PastListenCount,
			&i.LastListenedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
