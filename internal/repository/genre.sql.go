// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: genre.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const associateGenreToArtist = `-- name: AssociateGenreToArtist :exec
INSERT INTO artist_genres (artist_id, genre_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssociateGenreToArtistParams struct {
	ArtistID int32
	GenreID  int32
}

func (q *Queries) AssociateGenreToArtist(ctx context.Context, arg AssociateGenreToArtistParams) error {
	_, err := q.db.Exec(ctx, associateGenreToArtist, arg.ArtistID, arg.GenreID)
	return err
}

const associateGenreToRelease = `-- name: AssociateGenreToRelease :exec
INSERT INTO release_genres (release_id, genre_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssociateGenreToReleaseParams struct {
	ReleaseID int32
	GenreID   int32
}

func (q *Queries) AssociateGenreToRelease(ctx context.Context, arg AssociateGenreToReleaseParams) error {
	_, err := q.db.Exec(ctx, associateGenreToRelease, arg.ReleaseID, arg.GenreID)
	return err
}

const deleteArtistGenres = `-- name: DeleteArtistGenres :exec
DELETE FROM artist_genres WHERE artist_id = $1
`

func (q *Queries) DeleteArtistGenres(ctx context.Context, artistID int32) error {
	_, err := q.db.Exec(ctx, deleteArtistGenres, artistID)
	return err
}

const deleteReleaseGenres = `-- name: DeleteReleaseGenres :exec
DELETE FROM release_genres WHERE release_id = $1
`

func (q *Queries) DeleteReleaseGenres(ctx context.Context, releaseID int32) error {
	_, err := q.db.Exec(ctx, deleteReleaseGenres, releaseID)
	return err
}

const getArtistsWithoutGenres = `-- name: GetArtistsWithoutGenres :many
SELECT a.id, a.musicbrainz_id
FROM artists a
WHERE a.musicbrainz_id IS NOT NULL
  AND a.id > $2
  AND NOT EXISTS (
    SELECT 1 FROM artist_genres ag WHERE ag.artist_id = a.id
  )
ORDER BY a.id ASC
LIMIT $1
`

type GetArtistsWithoutGenresParams struct {
	Limit int32
	ID    int32
}

type GetArtistsWithoutGenresRow struct {
	ID            int32
	MusicBrainzID *uuid.UUID
}

func (q *Queries) GetArtistsWithoutGenres(ctx context.Context, arg GetArtistsWithoutGenresParams) ([]GetArtistsWithoutGenresRow, error) {
	rows, err := q.db.Query(ctx, getArtistsWithoutGenres, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArtistsWithoutGenresRow
	for rows.Next() {
		var i GetArtistsWithoutGenresRow
		if err := rows.Scan(&i.ID, &i.MusicBrainzID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenreByName = `-- name: GetGenreByName :one
SELECT id, name FROM genres WHERE name = $1 LIMIT 1
`

func (q *Queries) GetGenreByName(ctx context.Context, name string) (Genre, error) {
	row := q.db.QueryRow(ctx, getGenreByName, name)
	var i Genre
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getGenreStatsByListenCount = `-- name: GetGenreStatsByListenCount :many
SELECT
    g.name,
    COUNT(l.listened_at) AS listen_count
FROM listens l
JOIN tracks t ON l.track_id = t.id
JOIN releases r ON t.release_id = r.id
JOIN release_genres rg ON r.id = rg.release_id
JOIN genres g ON rg.genre_id = g.id
WHERE l.listened_at BETWEEN $1 AND $2
GROUP BY g.name
ORDER BY listen_count DESC
`

type GetGenreStatsByListenCountParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
}

type GetGenreStatsByListenCountRow struct {
	Name        string
	ListenCount int64
}

func (q *Queries) GetGenreStatsByListenCount(ctx context.Context, arg GetGenreStatsByListenCountParams) ([]GetGenreStatsByListenCountRow, error) {
	rows, err := q.db.Query(ctx, getGenreStatsByListenCount, arg.ListenedAt, arg.ListenedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGenreStatsByListenCountRow
	for rows.Next() {
		var i GetGenreStatsByListenCountRow
		if err := rows.Scan(&i.Name, &i.ListenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenreStatsByTimeListened = `-- name: GetGenreStatsByTimeListened :many
SELECT
    g.name,
    COALESCE(SUM(t.duration), 0)::BIGINT AS seconds_listened
FROM listens l
JOIN tracks t ON l.track_id = t.id
JOIN releases r ON t.release_id = r.id
JOIN release_genres rg ON r.id = rg.release_id
JOIN genres g ON rg.genre_id = g.id
WHERE l.listened_at BETWEEN $1 AND $2
GROUP BY g.name
ORDER BY seconds_listened DESC
`

type GetGenreStatsByTimeListenedParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
}

type GetGenreStatsByTimeListenedRow struct {
	Name            string
	SecondsListened int64
}

func (q *Queries) GetGenreStatsByTimeListened(ctx context.Context, arg GetGenreStatsByTimeListenedParams) ([]GetGenreStatsByTimeListenedRow, error) {
	rows, err := q.db.Query(ctx, getGenreStatsByTimeListened, arg.ListenedAt, arg.ListenedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGenreStatsByTimeListenedRow
	for rows.Next() {
		var i GetGenreStatsByTimeListenedRow
		if err := rows.Scan(&i.Name, &i.SecondsListened); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenresByNames = `-- name: GetGenresByNames :many
SELECT id, name FROM genres WHERE name = ANY($1::text[])
`

func (q *Queries) GetGenresByNames(ctx context.Context, dollar_1 []string) ([]Genre, error) {
	rows, err := q.db.Query(ctx, getGenresByNames, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenresForArtist = `-- name: GetGenresForArtist :many
SELECT g.id, g.name
FROM genres g
JOIN artist_genres ag ON g.id = ag.genre_id
WHERE ag.artist_id = $1
`

func (q *Queries) GetGenresForArtist(ctx context.Context, artistID int32) ([]Genre, error) {
	rows, err := q.db.Query(ctx, getGenresForArtist, artistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenresForRelease = `-- name: GetGenresForRelease :many
SELECT g.id, g.name
FROM genres g
JOIN release_genres rg ON g.id = rg.genre_id
WHERE rg.release_id = $1
`

func (q *Queries) GetGenresForRelease(ctx context.Context, releaseID int32) ([]Genre, error) {
	rows, err := q.db.Query(ctx, getGenresForRelease, releaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReleasesWithoutGenres = `-- name: GetReleasesWithoutGenres :many
SELECT r.id, r.musicbrainz_id
FROM releases r
WHERE r.musicbrainz_id IS NOT NULL
  AND r.id > $2
  AND NOT EXISTS (
    SELECT 1 FROM release_genres rg WHERE rg.release_id = r.id
  )
ORDER BY r.id ASC
LIMIT $1
`

type GetReleasesWithoutGenresParams struct {
	Limit int32
	ID    int32
}

type GetReleasesWithoutGenresRow struct {
	ID            int32
	MusicBrainzID *uuid.UUID
}

func (q *Queries) GetReleasesWithoutGenres(ctx context.Context, arg GetReleasesWithoutGenresParams) ([]GetReleasesWithoutGenresRow, error) {
	rows, err := q.db.Query(ctx, getReleasesWithoutGenres, arg.Limit, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReleasesWithoutGenresRow
	for rows.Next() {
		var i GetReleasesWithoutGenresRow
		if err := rows.Scan(&i.ID, &i.MusicBrainzID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGenre = `-- name: InsertGenre :one
INSERT INTO genres (name)
VALUES ($1)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name
`

func (q *Queries) InsertGenre(ctx context.Context, name string) (Genre, error) {
	row := q.db.QueryRow(ctx, insertGenre, name)
	var i Genre
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
